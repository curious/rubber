# This is a sample Capistrano config file for rubber

# Curious: configure newrelic deployment notification hooks
require 'new_relic/recipes'
# Curious: ensure that bundler installs gems during deployment into shared/bundle
require 'bundler/capistrano'
# Curious: This is for deploy:web:enable and deploy:web:disable tasks
require 'capistrano/maintenance'

set :rails_env, Rubber.env

# Curious: configure capistrano multitage (capistrano-ext gem) to allow custom 
# deployment rules per environment,
set :stages, %w(production qa externaldev partners)
set :default_stage, Rubber.env
require 'capistrano/ext/multistage'

on :load do
  set :application, rubber_env.app_name
  set :runner,      rubber_env.app_user
  set :deploy_to,   "/mnt/#{application}-#{Rubber.env}"
  set :copy_exclude, [".git/*", ".bundle/*", "log/*", ".rvmrc", ".rbenv-version", ".git", ".bundle"] # Curious: don't deploy empty .git/.bundle directories]
  set :assets_role, [:app]
end

# Curious: Deploy from our private github repository.  Deploy works using ssh keys forwarded 
# from the server running Capistrano.  When a developer runs 'cap deploy', the server
# will attempt to access Github using the developer's ssh key.  When Jenkins runs
# 'cap deploy', the server will attempt to access Github using the ssh key for the
# jenkins@<build server> key, which must be manually added to the 'curious-builds'
# account on Github.
# See http://help.github.com/deploy-with-capistrano/
set :scm, "git"
set :repository, "git@github.com:kartofflly/PlayerPrototype.git"
set :deploy_via, :remote_cache
set :ssh_options, { :forward_agent => true }
set :git_enable_submodules, 1 # tell git to fetch our vendor/* submodules
# :branch is set in multistage files

# Easier to do system level config as root - probably should do it through
# sudo in the future.  We use ssh keys for access, so no passwd needed
set :user, 'root'
set :password, nil

# Use sudo with user rails for cap deploy:[stop|start|restart]
# This way exposed services (mongrel) aren't running as a privileged user
set :use_sudo, true

# How many old releases should be kept around when running "cleanup" task
set :keep_releases, 3

# Lets us work with staging instances without having to checkin config files
# (instance*.yml + rubber*.yml) for a deploy.  This gives us the
# convenience of not having to checkin files for staging, as well as 
# the safety of forcing it to be checked in for production.
set :push_instance_config, Rubber.env != 'production'

# don't waste time bundling gems that don't need to be there 
set :bundle_without, [:development, :test, :staging] if Rubber.env == 'production'

# Allow us to do N hosts at a time for all tasks - useful when trying
# to figure out which host in a large set is down:
# RUBBER_ENV=production MAX_HOSTS=1 cap invoke COMMAND=hostname
max_hosts = ENV['MAX_HOSTS'].to_i
default_run_options[:max_hosts] = max_hosts if max_hosts > 0

# Allows the tasks defined to fail gracefully if there are no hosts for them.
# Comment out or use "required_task" for default cap behavior of a hard failure
rubber.allow_optional_tasks(self)

# Wrap tasks in the deploy namespace that have roles so that we can use FILTER
# with something like a deploy:cold which tries to run deploy:migrate but can't
# because we filtered out the :db role
namespace :deploy do
  rubber.allow_optional_tasks(self)
  tasks.values.each do |t|
    if t.options[:roles]
      task t.name, t.options, &t.body
    end
  end
end

namespace :deploy do
  namespace :assets do
    rubber.allow_optional_tasks(self)
    tasks.values.each do |t|
      if t.options[:roles]
        task t.name, t.options, &t.body
      end
    end
  end
end

# Curious: customize the maintenance page created by capistrano's deploy:web:disable task.
# See https://github.com/tvdeyen/capistrano-maintenance
# See https://github.com/capistrano/capistrano/commit/4ece7902d5 for discussion
# of the removal of deploy:web:enable and deploy:web:diable from capistrano-core.
# use local template instead of included one with capistrano-maintenance
set :maintenance_template_path, 'app/views/layouts/maintenance.html.erb'
# disable the warning on how to configure your server
set :maintenance_config_warning, false

require "net/http"

namespace :deploy do
  # Curious: in a multi-server environment, the names of assets files must be identical 
  # across all servers in the pool.  Otherwise, asset requests may get load-balanced 
  # to a server that has a different filename, resulting in a 404.
  # Verify that all servers have the same assets by comparing checksums of the
  # manifest.yml on each server generated by the Rails asset pipeline.
  namespace :assets do
    task :verify_manifests, :roles => [:web], :except => {:no_release => true} do
      prev_checksum = nil
      servers = find_servers_for_task(current_task)
      servers.map do |s|
        begin
          uri = URI.parse "http://#{s.host}/assets/manifest.yml"
          response = Net::HTTP.get_response(uri)
          checksum = Digest::MD5.hexdigest(response.body)
          puts "Verifying manifest: #{uri}, checksum = #{checksum}"
          if (prev_checksum ||= checksum) != checksum
            fail "Detected difference in #{uri} (checksum = #{checksum}, prev checksum = #{prev_checksum}). This will result in missing assets on the CDN!"
          end
        rescue Exception => e
          # Ignore any errors (e.g., Connection refused) as this may be caused by the server
          # having code deployed to it for the first time (the web server may not be running yet)
          puts "Unable to verify manifest for host: #{s.host}, exception: #{e}"
        end
      end
      puts "All servers have identical asset manifests (checksum = #{prev_checksum})"
    end
  end

  # Curious: convenience tasks for deploying secret credentials to newly-created servers.
  namespace :credentials do
    def put_credentials(path, desc)
      credentials = Capistrano::CLI.password_prompt "Enter #{desc}: "
      if credentials && !credentials.empty?
        put credentials, path, :mode => 0400
        rsudo "chown #{rubber_env.app_user}:#{rubber_env.app_user} #{path}"
      else
        fail "Please enter the #{desc}."
      end
    end

    desc "Write database credentials to a remote server."
    task :db do
      put_credentials("/home/app/.db", "database password")
    end

    desc "Write Balanced credentials to a remote server."
    task :balanced do
      put_credentials("/home/app/.balanced", "Balanced API key")
    end
  end
end

if Rubber::Util.has_asset_pipeline?
  # Curious: after deployment, ensure that compiled asset manifests are identical across all hosts
  after "deploy:assets:precompile", "deploy:assets:verify_manifests"
  # Curious: FIXME: re-add after figuring out why turbo-sprockets-rails3 leaves some assets uncompiled
  # after deployment, ask turbo-sprockets-rails3 to clean up assets that have been deployed for at least 2 weeks
  # after "deploy:assets:precompile", "deploy:assets:clean_expired"
end

# load in the deploy scripts installed by vulcanize for each rubber module
Dir["#{File.dirname(__FILE__)}/rubber/deploy-*.rb"].each do |deploy_file|
  load deploy_file
end

# capistrano's deploy:cleanup doesn't play well with FILTER
after "deploy", "cleanup"
after "deploy:migrations", "cleanup"
task :cleanup, :except => { :no_release => true } do
  count = fetch(:keep_releases, 5).to_i
  
  rsudo <<-CMD
    all=$(ls -x1 #{releases_path} | sort -n);
    keep=$(ls -x1 #{releases_path} | sort -n | tail -n #{count});
    remove=$(comm -23 <(echo -e "$all") <(echo -e "$keep"));
    for r in $remove; do rm -rf #{releases_path}/$r; done;
  CMD
end

# We need to ensure that rubber:config runs before asset precompilation in Rails, as Rails tries to boot the environment,
# which means needing to have DB access.  However, if rubber:config hasn't run yet, then the DB config will not have
# been generated yet.  Rails will fail to boot, asset precompilation will fail to complete, and the deploy will abort.
if Rubber::Util.has_asset_pipeline?
  load 'deploy/assets'

  callbacks[:after].delete_if {|c| c.source == "deploy:assets:precompile"}
  callbacks[:before].delete_if {|c| c.source == "deploy:assets:symlink"}
  before "deploy:assets:precompile", "deploy:assets:symlink"
  after "rubber:config", "deploy:assets:precompile"
end

# Curious: Notify NewRelic of deployments so they will show up on our performance graphs.
# See https://rpm.newrelic.com/accounts/79699/applications/1158697/deployments
after "deploy:migrations", "newrelic:notice_deployment"

# Curious: Allow execution of rake tasks on remote machines
# See http://stackoverflow.com/questions/312214/how-do-i-run-a-rake-task-from-capistrano
desc "Run a task on a remote server."  
# run like: RUBBER_ENV=qa FILTER=qa01 cap invoke_rake task=a_certain_task
task :invoke_rake do
  run("cd #{deploy_to}/current; #{rake} #{ENV['task']} RAILS_ENV=#{rails_env}")
end  
