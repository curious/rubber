<%
  @path = "/etc/nginx/rubber/application.conf"
  # Curious: create subdirectories under the nginx directory for storing large uploads.
  @post = <<-POST
    mkdir -p #{rubber_env.nginx_temp_path}/{0..9}/{0..9}
    # /mnt/tmp
    chmod a+rw #{rubber_env.rails_temp_path}
    # /mnt/tmp/nginx
    chmod a+rw #{rubber_env.nginx_temp_path}
    # /mnt/tmp/nginx/{1..9}
    chmod a+rw #{rubber_env.nginx_temp_path}/{0..9}
    # /mnt/tmp/nginx/{1..9}/{1..9}
    chmod a+rw #{rubber_env.nginx_temp_path}/{0..9}/{0..9}
  POST
%>

server_name  <%= [ rubber_env.domain, rubber_env.web_aliases ].flatten.compact.join(" ") %>;
passenger_enabled on;
passenger_env_var HTTP_X_QUEUE_START "t=${msec}000";

root <%= Rubber.root + "/public" %>;

# Curious: this is to make sure we get the client's actual ip, rather than the 
# load-balancer. we always want to pay attention to the real_ip.
set_real_ip_from 0.0.0.0/0;
real_ip_header X-Forwarded-For;

<% unless Rubber.env == 'production' %>
# Curious: IP or Password protect all internal sites (qa, exdev).  Allow open access to production (www).
# See http://stackoverflow.com/questions/4171454/password-protecting-rails-site-running-on-nginx-and-phusion-passenger
# whitelisted IPs will be able to access without a password.  All others will require http auth.
# see: http://forum.nginx.org/read.php?2,225266,225267#msg-225267
location / {
  passenger_enabled on;

  # this says that we just have to satisfy one of the allow conditions (IP or auth)
  satisfy any;

  # curious IPs
  allow 98.207.153.0/24;
  allow 75.144.249.0/24;

  # curious John's home IP (iPad app doesn't play well with httpauth)
  allow 98.234.153.122;
  allow 98.234.157.196;

  # curious Heather's Home IP (iPad app doesn't play well with httpauth)
  allow 50.152.172.205;
  allow 76.14.49.117;

  # curious London Office IP
  allow 86.153.171.82;

  # Juan's IP
  allow 75.54.223.114;

  # OveractDev IPs (St. George, Jared Reed, Mountain View, Orem)
  allow 74.211.27.0/24;
  allow 74.211.30.0/24;
  allow 208.83.107.0/24;
  allow 173.10.23.0/24;
  allow 67.186.230.0/24;

  # OveractDev Paul
  allow 75.71.186.59;

  # OveractDev Irina
  allow 71.198.229.73;

  # OveractDev MV Townhouse
  allow 98.248.220.60;
  
  # OveractDev Mike
  allow 76.23.53.61;

  # facebook IPs (so their scraper can see us).
  # you can get an updated list here: http://developers.facebook.com/docs/ApplicationSecurity/
  allow 31.13.24.0/21;
  allow 31.13.64.0/18;
  allow 66.220.144.0/20;
  allow 69.63.176.0/20;
  allow 69.171.224.0/19;
  allow 74.119.76.0/22;
  allow 103.4.96.0/22;
  allow 173.252.64.0/18;
  allow 204.15.20.0/22;

  location ~ ^/(tp.gif|favicon.ico) {
    allow all;
  }

  # deny all the rest
  deny all;

  auth_basic "RESTRICTED ACCESS";
  auth_basic_user_file <%= Rubber.root + "/config/.htpasswd" %>;
}

# Curious: allow access to /status so that a load balancer can use it as a health 
# check even in environments like QA that are otherwise locked down.
location = /status {
  passenger_enabled on;
  allow all;
}
<% end %>

# this rewrites all the requests to the maintenance.html
# page if it exists in the doc root. This is for capistrano's
# disable web task
# Curious: We need to allow an exception for /status, as it is used by Amazon's ELB 
#      as a health-check.  Even when the server is in maintenance mode, it is 
#      important that the ELB consider it healthy and keep it in the pool,
#      otherwise during maintenance mode all instances will be dropped and the 
#      pool left empty/non-responsive.  The cumbersome if/set/if pattern below
#      is required because nginx does not support multiple if conditions or nested
#      if directives.  See http://stackoverflow.com/questions/4833238/nginx-conf-redirect-multiple-conditions
set $maintenance 0;
if (-f $document_root/system/maintenance.html)
{
  set $maintenance 1;
}
if ($uri ~ /status) {
  set $maintenance 0;
}
if ($maintenance = 1) {
  return 503;
}

# Curious: return a "503 Service Temporarily Unavailable" status code when the site is down for maintenance.
# This will prevent Google or other spiders from caching the maintenance page content.
# See:
# - http://ariejan.net/2011/09/19/capistrano-and-the-custom-maintenance-page
# - http://lincolnloop.com/blog/2010/feb/12/pro-tip-redirecting-custom-nginx-maintenance-page/
error_page 503 @maintenance;
location @maintenance {
  rewrite  ^(.*)$  /system/maintenance.html last;
  break;
}

# Curious: move error pages under the /error directory so the error codes (/500)
# do not conflict with user ids (/500)
error_page   500 502 504  /errors/500.html;
location = /errors/500.html
{
  root <%= Rubber.root + "/public" %>;
}
error_page 404  /errors/404.html;
location = /errors/404.html
{
  root <%= Rubber.root + "/public" %>;
}

# Curious: we configure Google Analytics to mirror all tracking hits so that they 
# get sent to both GA and our servers.  In order to avoid expensive rails
# processing, use nginx to return a simple transparent gif.  The desired
# tracking data can be parsed out of the nginx access log.
# later using scripts/reports/parse_tracking_from_nginx_access_log.rb
#
# # TODO: temporarily disabled in order to use track controller to log metrics.
#
# location = /__utm.gif
# {
#   empty_gif;
# }

<% if Rubber::Util.has_asset_pipeline? %>
# See http://guides.rubyonrails.org/asset_pipeline.html
#
# Enable far-future (1 year) expires headers for assets precompiled via the Rails asset pipeline.
# Precompiled assets include an MD5 checksum in their name, so far-future expires headers are safe.
#
# Tell nginx to serve precompiled, pre-gzipped content directly from disk.
# The Rails asset pipeline outputs both the compiled asset (foo-MD5.css) and 
# an aggressively-gzipped copy (foo-MD5.css.gz).  Let nginx serve the .gz 
# version directly.
location ~ ^/assets/ {
<% unless Rubber.env == 'production' %>
  # Curious: Allow anyone to access files under /assets/.  We are primarily concerned
  # with protecting access to the staging website, not static assets.
  # This makes testing on old IE much easier as you don't have to enter
  # the basic auth password repeatedly!
  allow all;
<% end %>

  root <%= Rubber.root + "/public" %>;
  gzip_static on; # to serve pre-gzipped version

  # Per Rails asset pipeline docs for nginx (sec 4.1.1 Server Configuration)
  expires    max;
  add_header Cache-Control public;
  add_header ETag "";
  add_header Last-Modified "";

  # Curious: Per Google PageSpeed:
  #   "Some public proxies have bugs that do not detect the presence of the Content-Encoding 
  #   response header. This can result in compressed versions being delivered to client browsers 
  #   that cannot properly decompress the files.
  #   Set the Vary: Accept-Encoding response header. This instructs the proxies to cache two 
  #   versions of the resource: one compressed, and one uncompressed. The correct version of 
  #   the resource is delivered based on the client request header. This is a good choice for 
  #   applications that are singly homed and depend on public proxies for user locality."
  # See https://developers.google.com/speed/docs/best-practices/caching#LeverageProxyCaching
  add_header Vary Accept-Encoding;
 
  break;
}
<% end %>

# Curious: nginx does not appear to have any way to filter sensitive information out of its access logs.
# In order to avoid recording passwords sent as GET paramters via JSONP requests to aysnc_signup
# and async_login, we use a special log format that simply filters out the entire request string.
# (A regexp that only removed the password paramter would be better, but I haven't found any docs 
# explaining how to scrub individual parts out of the access log without using the nginx lua module,
# which we don't have installed.)
location ~ ^/async_(signup|login).jsonp {
  passenger_enabled on;
  access_log <%= rubber_env.nginx_log_dir %>/access.log filter_parameters;
}

# Curious: See http://wiki.nginx.org/HttpCoreModule#client_max_body_size
# Increase maximum file upload size to 3GB in order to allow clients to upload large videos.
# NOTE - ```client_max_body_size``` should: 
#  * match ```config.max_file_sizes[:storage_file_file]``` setting in application.rb
#  * match or exceed all plupload ```max_file_size settings``` in client javascript (ResourceUploader.js.coffee & 
#    ProjectSubmissionResourceUploader.js.coffee)
client_max_body_size 3072M;
# Curious: Change nginx default path for storing uploaded files from /tmp (limited to the 8gb 
# available on the root filesystem for EBS-backed AMIs) to /mnt/tmp (150gb ephemeral instance storage).
# NOTE: /mnt/tmp/[0-9]/[0-9] directories must exist
client_body_temp_path <%= rubber_env.nginx_temp_path %> 1 1;
error_page   413  /errors/413.html;
location = /errors/413.html
{
  root <%= Rubber.root + "/public" %>;
}

# Curious: See https://github.com/h5bp/server-configs/issues/4
# Per HTML5 Boilerplate, serve "X-UA-Compatible" header to prevent IE from
# falling back to compatibility mode.
# opt-in to the future
add_header "X-UA-Compatible" "IE=Edge,chrome=1";

# Curious: Allow Rails to request that nginx send a static file back to the client via the X-Accel-Redirect header.
# This allows the app server to offload serving off static assets to nginx, which it is optimized for.
# Required for Resque-server css/js work: http://blog.kiskolabs.com/post/776939029/rails3-resque-devise
# See http://stackoverflow.com/questions/3724853/rails-sends-0-byte-files-using-send-file/3727122#3727122
sendfile on;
